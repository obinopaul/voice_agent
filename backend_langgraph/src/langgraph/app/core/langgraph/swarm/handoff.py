import re
from dataclasses import is_dataclass
from typing import Annotated, Any
from typing import List, Sequence, TypedDict, Annotated, Optional
from langchain_core.messages import ToolMessage, HumanMessage
from langchain_core.tools import BaseTool, InjectedToolCallId, tool
from langgraph.graph.state import CompiledStateGraph
from langgraph.prebuilt import InjectedState, ToolNode
from langgraph.types import Command
from pydantic import BaseModel


def _get_field(obj: Any, key: str) -> Any:
    """Get a field from an object.

    This function retrieves a field from a dictionary, dataclass, or Pydantic model.

    Args:
        obj: The object from which to retrieve the field.
        key: The key or attribute name of the field to retrieve.

    Returns:
        The value of the specified field.

    """
    if isinstance(obj, dict):
        return obj[key]
    if is_dataclass(obj) or isinstance(obj, BaseModel):
        return getattr(obj, key)
    msg = f"Unsupported type for state: {type(obj)}"
    raise TypeError(msg)


WHITESPACE_RE = re.compile(r"\s+")
METADATA_KEY_HANDOFF_DESTINATION = "__handoff_destination"


def _normalize_agent_name(agent_name: str) -> str:
    """Normalize an agent name to be used inside the tool name."""
    return WHITESPACE_RE.sub("_", agent_name.strip()).lower()


def create_handoff_tool(
    *,
    agent_name: str,
    name: str | None = None,
    description: str | None = None,
) -> BaseTool:
    """Create a tool that can handoff control to the requested agent.

    Args:
        agent_name: The name of the agent to handoff control to, i.e.
            the name of the agent node in the multi-agent graph.
            Agent names should be simple, clear and unique, preferably in snake_case,
            although you are only limited to the names accepted by LangGraph
            nodes as well as the tool names accepted by LLM providers
            (the tool name will look like this: `transfer_to_<agent_name>`).
        name: Optional name of the tool to use for the handoff.
            If not provided, the tool name will be `transfer_to_<agent_name>`.
        description: Optional description for the handoff tool.
            If not provided, the tool description will be `Ask agent <agent_name> for help`.

    """
    if name is None:
        name = f"transfer_to_{_normalize_agent_name(agent_name)}"

    if description is None:
        description = f"Ask agent '{agent_name}' for help"

    # @tool(name, description=description)
    # def handoff_to_agent(
    #     # Annotation is typed as Any instead of StateLike. StateLike
    #     # trigger validation issues from Pydantic / langchain_core interaction.
    #     # https://github.com/langchain-ai/langchain/issues/32067
    #     task: str,
    #     state: Annotated[Any, InjectedState],
    #     tool_call_id: Annotated[str, InjectedToolCallId],
    # ) -> Command:
        
    #     """
    #     Handoffs control to another agent with a specific task, preserving the full conversation history.

    #     Args:
    #         task: A clear, natural language description of the task for the next agent. This is generated by the calling agent.
    #         state: The entire current state of the graph, automatically injected.
    #         tool_call_id: The ID of the tool call, automatically injected.
    #     """
    #     tool_message = ToolMessage(
    #         content=f"Successfully transferred to {agent_name} with task: {task}",
    #         name=name,
    #         tool_call_id=tool_call_id,
    #     )
    #     # The new message for the next agent is the task itself, which will be appended to the history.
    #     new_message = HumanMessage(content=task)
        
    #     return Command(
    #         goto=agent_name,
    #         graph=Command.PARENT,
    #         update={
    #             "messages": [*_get_field(state, "messages"), tool_message, new_message],
    #             "active_agent": agent_name,
    #         },
    #     )


    @tool(name, description=description)
    def handoff_to_agent(
        task: str,
        # state: Annotated[Optional[Any], InjectedState] = None,
        state: Annotated[dict, InjectedState],
        tool_call_id: Annotated[str, InjectedToolCallId],
        # tool_call_id: Annotated[Optional[str], InjectedToolCallId] = None,
    ) -> Command:
        """
        Handoffs control to another agent with a specific task, preserving the full conversation history.

        Args:
            task: A clear, natural language description of the task for the next agent. This is generated by the calling agent.
            state: The entire current state of the graph, automatically injected.
            tool_call_id: The ID of the tool call, automatically injected.
        """
        
        # --- ADD THESE PRINT STATEMENTS ---
        print(f"\n[DEBUG handoff.py] --- Handoff Tool Executing ---")
        print(f"[DEBUG handoff.py] Handoff to: '{agent_name}' with task: '{task}'")
        print(f"[DEBUG handoff.py] Received state type: {type(state)}")
        
        
        # --- THE FIX ---
        # This check handles the critical failure where the graph does not inject the state.
        if state is None or tool_call_id is None:
            # Instead of crashing, we return a Command with an error message.
            # This allows the agent to see the failure and attempt to recover.

            # --- ADD THIS PRINT STATEMENT ---
            print(f"[DEBUG handoff.py] ERROR: State is None! Injection failed.")
            
            error_content = (
                "Error: Agent state was not injected into the handoff tool. "
                "Cannot transfer with full history. This is a critical internal graph error."
            )
            # We must provide a tool_call_id to create a valid ToolMessage.
            # If it's missing, we report the error as a HumanMessage.
            if tool_call_id:
                error_message = ToolMessage(
                    content=error_content, name=name, tool_call_id=tool_call_id
                )
            else:
                error_message = HumanMessage(content=f"FATAL TOOL ERROR: {error_content}")

            return Command(update={"messages": [error_message]})

        # --- ADD THIS PRINT STATEMENT ---
        if isinstance(state, dict):
            print(f"[DEBUG handoff.py] State received with keys: {list(state.keys())}")
        else:
            print(f"[DEBUG handoff.py] State is not a dict, it's a {type(state)}")
            
        tool_message = ToolMessage(
            content=f"Successfully transferred to {agent_name} with task: {task}",
            name=name,
            tool_call_id=tool_call_id,
        )
        # The new message for the next agent is the task itself, which will be appended to the history.
        new_message = HumanMessage(content=task)
        
        return Command(
            goto=agent_name,
            graph=Command.PARENT,
            update={
                # This line correctly unpacks the history from the (now validated) state object.
                "messages": [*_get_field(state, "messages"), tool_message, new_message],
                "active_agent": agent_name,
            },
        )
        
        
    handoff_to_agent.metadata = {METADATA_KEY_HANDOFF_DESTINATION: agent_name}
    return handoff_to_agent


def get_handoff_destinations(
    agent: CompiledStateGraph, tool_node_name: str = "tools"
) -> list[str]:
    """Get a list of destinations from agent's handoff tools."""
    nodes = agent.get_graph().nodes
    if tool_node_name not in nodes:
        return []

    tool_node = nodes[tool_node_name].data
    if not isinstance(tool_node, ToolNode):
        return []

    tools = tool_node.tools_by_name.values()
    return [
        tool.metadata[METADATA_KEY_HANDOFF_DESTINATION]
        for tool in tools
        if tool.metadata is not None
        and METADATA_KEY_HANDOFF_DESTINATION in tool.metadata
    ]